"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const esutils = __importStar(require("esutils"));
const t = __importStar(require("../shared/estree"));
const types_1 = require("../shared/types");
const utils_1 = require("../shared/utils");
const RENDER_APIS = {
    iterator: { name: 'i', alias: 'api_iterator' },
    flatten: { name: 'f', alias: 'api_flatten' },
    element: { name: 'h', alias: 'api_element' },
    slot: { name: 's', alias: 'api_slot' },
    customElement: { name: 'c', alias: 'api_custom_element' },
    dynamicCtor: { name: 'dc', alias: 'api_dynamic_component' },
    bind: { name: 'b', alias: 'api_bind' },
    text: { name: 't', alias: 'api_text' },
    dynamicText: { name: 'd', alias: 'api_dynamic_text' },
    key: { name: 'k', alias: 'api_key' },
    tabindex: { name: 'ti', alias: 'api_tab_index' },
    scopedId: { name: 'gid', alias: 'api_scoped_id' },
    scopedFragId: { name: 'fid', alias: 'api_scoped_frag_id' },
    comment: { name: 'co', alias: 'api_comment' },
};
class CodeGen {
    constructor({ root, config, scopeFragmentId, }) {
        var _a, _b, _c, _d, _e;
        this.currentId = 0;
        this.currentKey = 0;
        this.usedApis = {};
        this.usedSlots = {};
        this.usedLwcApis = new Set();
        this.slotNames = new Set();
        this.memorizedIds = [];
        this.referencedComponents = new Set();
        this.root = root;
        this.renderMode = (_b = (_a = root.lwc) === null || _a === void 0 ? void 0 : _a.renderMode) !== null && _b !== void 0 ? _b : types_1.LWCDirectiveRenderMode.shadow;
        this.preserveComments = (_e = (_d = (_c = root.lwc) === null || _c === void 0 ? void 0 : _c.preserveComments) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : config.preserveHtmlComments;
        this.scopeFragmentId = scopeFragmentId;
    }
    generateKey() {
        return this.currentKey++;
    }
    genElement(tagName, data, children) {
        return this._renderApiCall(RENDER_APIS.element, [t.literal(tagName), data, children]);
    }
    genCustomElement(tagName, componentClass, data, children) {
        this.referencedComponents.add(tagName);
        return this._renderApiCall(RENDER_APIS.customElement, [
            t.literal(tagName),
            componentClass,
            data,
            children,
        ]);
    }
    genDynamicElement(tagName, ctor, data, children) {
        return this._renderApiCall(RENDER_APIS.dynamicCtor, [
            t.literal(tagName),
            ctor,
            data,
            children,
        ]);
    }
    genText(value) {
        const mappedValues = value.map((v) => {
            return typeof v === 'string'
                ? t.literal(v)
                : this._renderApiCall(RENDER_APIS.dynamicText, [v]);
        });
        let textConcatenation = mappedValues[0];
        for (let i = 1, n = mappedValues.length; i < n; i++) {
            textConcatenation = t.binaryExpression('+', textConcatenation, mappedValues[i]);
        }
        return this._renderApiCall(RENDER_APIS.text, [textConcatenation]);
    }
    genComment(value) {
        return this._renderApiCall(RENDER_APIS.comment, [t.literal(value)]);
    }
    genIterator(iterable, callback) {
        return this._renderApiCall(RENDER_APIS.iterator, [iterable, callback]);
    }
    genBind(handler) {
        return this._renderApiCall(RENDER_APIS.bind, [handler]);
    }
    genFlatten(children) {
        return this._renderApiCall(RENDER_APIS.flatten, children);
    }
    genKey(compilerKey, value) {
        return this._renderApiCall(RENDER_APIS.key, [compilerKey, value]);
    }
    genScopedId(id) {
        if (typeof id === 'string') {
            return this._renderApiCall(RENDER_APIS.scopedId, [t.literal(id)]);
        }
        return this._renderApiCall(RENDER_APIS.scopedId, [id]);
    }
    genScopedFragId(id) {
        if (typeof id === 'string') {
            return this._renderApiCall(RENDER_APIS.scopedFragId, [t.literal(id)]);
        }
        return this._renderApiCall(RENDER_APIS.scopedFragId, [id]);
    }
    getSlot(slotName, data, children) {
        this.slotNames.add(slotName);
        return this._renderApiCall(RENDER_APIS.slot, [
            t.literal(slotName),
            data,
            children,
            t.identifier('$slotset'),
        ]);
    }
    genTabIndex(children) {
        return this._renderApiCall(RENDER_APIS.tabindex, children);
    }
    getMemorizationId() {
        const id = this._genUniqueIdentifier('_m');
        this.memorizedIds.push(id);
        return id;
    }
    genBooleanAttributeExpr(bindExpr) {
        return t.conditionalExpression(bindExpr, t.literal(''), t.literal(null));
    }
    _genUniqueIdentifier(name) {
        const id = this.currentId++;
        const prefix = this._toValidIdentifier(name);
        return t.identifier(prefix + id);
    }
    _toValidIdentifier(name) {
        return esutils.keyword.isIdentifierES6(name) ? name : (0, utils_1.toPropertyName)(name);
    }
    _renderApiCall(primitive, params) {
        const { name, alias } = primitive;
        let identifier = this.usedApis[name];
        if (!identifier) {
            identifier = this.usedApis[name] = t.identifier(alias);
        }
        return t.callExpression(identifier, params);
    }
}
exports.default = CodeGen;
//# sourceMappingURL=codegen.js.map