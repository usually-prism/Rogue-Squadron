"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseClassNames = exports.styleMapToStyleDeclsAST = exports.parseStyleText = exports.generateTemplateMetadata = exports.memorizeHandler = exports.hasIdAttribute = exports.shouldFlatten = exports.containsDynamicChildren = exports.objectToAST = exports.getMemberExpressionRoot = exports.identifierFromComponentName = void 0;
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const t = __importStar(require("../shared/estree"));
const utils_1 = require("../shared/utils");
const types_1 = require("../shared/types");
const ir_1 = require("../shared/ir");
const constants_1 = require("../shared/constants");
function identifierFromComponentName(name) {
    return t.identifier(`_${(0, utils_1.toPropertyName)(name)}`);
}
exports.identifierFromComponentName = identifierFromComponentName;
function getMemberExpressionRoot(expression) {
    let current = expression;
    while (t.isMemberExpression(current)) {
        current = current.object;
    }
    return current;
}
exports.getMemberExpressionRoot = getMemberExpressionRoot;
function objectToAST(obj, valueMapper) {
    return t.objectExpression(Object.keys(obj).map((key) => t.property(t.literal(key), valueMapper(key))));
}
exports.objectToAST = objectToAST;
function isDynamic(element) {
    var _a;
    return ((_a = element.lwc) === null || _a === void 0 ? void 0 : _a.dynamic) !== undefined;
}
function containsDynamicChildren(children) {
    return children.some((child) => (0, ir_1.isElement)(child) && isDynamic(child));
}
exports.containsDynamicChildren = containsDynamicChildren;
function shouldFlatten(children, codeGen) {
    return children.some((child) => (0, ir_1.isElement)(child) &&
        (isDynamic(child) ||
            !!child.forEach ||
            !!child.forOf ||
            (codeGen.renderMode === types_1.LWCDirectiveRenderMode.light && child.tag === 'slot') ||
            ((0, ir_1.isTemplate)(child) && shouldFlatten(child.children, codeGen))));
}
exports.shouldFlatten = shouldFlatten;
/**
 * Returns true if the AST element or any of its descendants use an id attribute.
 */
function hasIdAttribute(element) {
    var _a, _b;
    if (((_a = element.attrs) === null || _a === void 0 ? void 0 : _a.id) || ((_b = element.props) === null || _b === void 0 ? void 0 : _b.id)) {
        return true;
    }
    for (const child of element.children) {
        if (child.type === 'element' && hasIdAttribute(child)) {
            return true;
        }
    }
    return false;
}
exports.hasIdAttribute = hasIdAttribute;
function memorizeHandler(codeGen, element, parentStack, componentHandler, handler) {
    // #439 - The handler can only be memorized if it is bound to component instance
    const id = getMemberExpressionRoot(componentHandler);
    const shouldMemorizeHandler = (0, ir_1.isComponentProp)(id, element, parentStack);
    // Apply memorization if the handler is memorizable.
    //   $cmp.handlePress -> _m1 || ($ctx._m1 = b($cmp.handlePress))
    if (shouldMemorizeHandler) {
        const memorizedId = codeGen.getMemorizationId();
        const memorization = t.assignmentExpression('=', t.memberExpression(t.identifier(constants_1.TEMPLATE_PARAMS.CONTEXT), memorizedId), handler);
        handler = t.logicalExpression('||', memorizedId, memorization);
    }
    return handler;
}
exports.memorizeHandler = memorizeHandler;
function generateTemplateMetadata(codeGen) {
    const metadataExpressions = [];
    if (codeGen.slotNames.size) {
        const slotsProperty = t.memberExpression(t.identifier(constants_1.TEMPLATE_FUNCTION_NAME), t.identifier('slots'));
        const slotsArray = t.arrayExpression(Array.from(codeGen.slotNames)
            .sort()
            .map((slot) => t.literal(slot)));
        const slotsMetadata = t.assignmentExpression('=', slotsProperty, slotsArray);
        metadataExpressions.push(t.expressionStatement(slotsMetadata));
    }
    const stylesheetsMetadata = t.assignmentExpression('=', t.memberExpression(t.identifier(constants_1.TEMPLATE_FUNCTION_NAME), t.identifier('stylesheets')), t.arrayExpression([]));
    metadataExpressions.push(t.expressionStatement(stylesheetsMetadata));
    // ignore when shadow because we don't want to modify template unnecessarily
    if (codeGen.renderMode === types_1.LWCDirectiveRenderMode.light) {
        const renderModeMetadata = t.assignmentExpression('=', t.memberExpression(t.identifier(constants_1.TEMPLATE_FUNCTION_NAME), t.identifier('renderMode')), t.literal('light'));
        metadataExpressions.push(t.expressionStatement(renderModeMetadata));
    }
    return metadataExpressions;
}
exports.generateTemplateMetadata = generateTemplateMetadata;
const DECLARATION_DELIMITER = /;(?![^(]*\))/g;
const PROPERTY_DELIMITER = /:(.+)/;
// Borrowed from Vue template compiler.
// https://github.com/vuejs/vue/blob/531371b818b0e31a989a06df43789728f23dc4e8/src/platforms/web/util/style.js#L5-L16
function parseStyleText(cssText) {
    const styleMap = {};
    const declarations = cssText.split(DECLARATION_DELIMITER);
    for (const declaration of declarations) {
        if (declaration) {
            const [prop, value] = declaration.split(PROPERTY_DELIMITER);
            if (prop !== undefined && value !== undefined) {
                styleMap[prop.trim()] = value.trim();
            }
        }
    }
    return styleMap;
}
exports.parseStyleText = parseStyleText;
// Given a map of CSS property keys to values, return an array AST like:
// ['color', 'blue', false]    // { color: 'blue' }
// ['background', 'red', true] // { background: 'red !important' }
function styleMapToStyleDeclsAST(styleMap) {
    const styles = Object.entries(styleMap).map(([key, value]) => {
        const important = value.endsWith('!important');
        if (important) {
            // trim off the trailing "!important" (10 chars)
            value = value.substring(0, value.length - 10).trim();
        }
        return [key, value, important];
    });
    return t.arrayExpression(styles.map((arr) => t.arrayExpression(arr.map((val) => t.literal(val)))));
}
exports.styleMapToStyleDeclsAST = styleMapToStyleDeclsAST;
const CLASSNAME_DELIMITER = /\s+/;
function parseClassNames(classNames) {
    return classNames
        .split(CLASSNAME_DELIMITER)
        .map((className) => className.trim())
        .filter((className) => className.length);
}
exports.parseClassNames = parseClassNames;
//# sourceMappingURL=helpers.js.map