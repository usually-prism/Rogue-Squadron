"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("@lwc/shared");
const errors_1 = require("@lwc/errors");
const html_1 = require("./html");
const attribute_1 = require("./attribute");
const expression_1 = require("./expression");
const t = __importStar(require("../shared/estree"));
const parse5Utils = __importStar(require("../shared/parse5"));
const ir_1 = require("../shared/ir");
const types_1 = require("../shared/types");
const parser_1 = __importDefault(require("./parser"));
const constants_1 = require("./constants");
function attributeExpressionReferencesForOfIndex(attribute, forOf) {
    const { value } = attribute;
    // if not an expression, it is not referencing iterator index
    if (!t.isMemberExpression(value)) {
        return false;
    }
    const { object, property } = value;
    if (!t.isIdentifier(object) || !t.isIdentifier(property)) {
        return false;
    }
    if (forOf.iterator.name !== object.name) {
        return false;
    }
    return property.name === 'index';
}
function attributeExpressionReferencesForEachIndex(attribute, forEach) {
    const { index } = forEach;
    const { value } = attribute;
    // No index defined on foreach
    if (!index || !t.isIdentifier(index) || !t.isIdentifier(value)) {
        return false;
    }
    return index.name === value.name;
}
function parse(source, state) {
    const ctx = new parser_1.default(source, state.config);
    const fragment = (0, html_1.parseHTML)(ctx, source);
    if (ctx.warnings.length) {
        return { warnings: ctx.warnings };
    }
    const root = ctx.withErrorRecovery(() => {
        const templateRoot = getTemplateRoot(ctx, fragment);
        return parseElement(ctx, templateRoot);
    });
    return { root, warnings: ctx.warnings };
}
exports.default = parse;
function parseElement(ctx, elementNode) {
    const element = (0, ir_1.createElement)(elementNode);
    const parsedAttr = parseAttributes(ctx, element, elementNode);
    applyForEach(ctx, element, parsedAttr);
    applyIterator(ctx, element, parsedAttr);
    applyIf(ctx, element, parsedAttr);
    applyHandlers(ctx, element, parsedAttr);
    applyComponent(element);
    applySlot(ctx, element, parsedAttr);
    applyKey(ctx, element, parsedAttr);
    applyLwcDirectives(ctx, element, parsedAttr);
    applyAttributes(ctx, element, parsedAttr);
    validateElement(ctx, element, elementNode);
    validateAttributes(ctx, element, parsedAttr);
    validateProperties(ctx, element);
    parseChildren(ctx, element, elementNode);
    validateChildren(ctx, element);
    return element;
}
function parseChildren(ctx, parent, parse5Parent) {
    var _a;
    const parsedChildren = [];
    const children = ((_a = parse5Utils.getTemplateContent(parse5Parent)) !== null && _a !== void 0 ? _a : parse5Parent).childNodes;
    ctx.parentStack.push(parent);
    for (const child of children) {
        ctx.withErrorRecovery(() => {
            if (parse5Utils.isElementNode(child)) {
                const elmNode = parseElement(ctx, child);
                parsedChildren.push(elmNode);
            }
            else if (parse5Utils.isTextNode(child)) {
                const textNodes = parseText(ctx, child);
                parsedChildren.push(...textNodes);
            }
            else if (parse5Utils.isCommentNode(child)) {
                const commentNode = parseComment(child);
                parsedChildren.push(commentNode);
            }
        });
    }
    ctx.parentStack.pop();
    parent.children = parsedChildren;
}
function parseText(ctx, node) {
    const parsedTextNodes = [];
    // Extract the raw source to avoid HTML entity decoding done by parse5
    const location = node.sourceCodeLocation;
    const rawText = (0, html_1.cleanTextNode)(ctx.getSource(location.startOffset, location.endOffset));
    if (!rawText.trim().length) {
        return parsedTextNodes;
    }
    // Split the text node content arround expression and create node for each
    const tokenizedContent = rawText.split(constants_1.EXPRESSION_RE);
    for (const token of tokenizedContent) {
        // Don't create nodes for emtpy strings
        if (!token.length) {
            continue;
        }
        let value;
        if ((0, expression_1.isExpression)(token)) {
            value = (0, expression_1.parseExpression)(ctx, token, location);
        }
        else {
            value = (0, html_1.decodeTextContent)(token);
        }
        parsedTextNodes.push((0, ir_1.createText)(node, value));
    }
    return parsedTextNodes;
}
function parseComment(node) {
    const value = (0, html_1.decodeTextContent)(node.data);
    return (0, ir_1.createComment)(node, value);
}
function getTemplateRoot(ctx, documentFragment) {
    // Filter all the empty text nodes
    const validRoots = documentFragment.childNodes.filter((child) => parse5Utils.isElementNode(child) ||
        (parse5Utils.isTextNode(child) && child.value.trim().length));
    if (validRoots.length > 1) {
        const duplicateRoot = validRoots[1].sourceCodeLocation;
        ctx.throwAtLocation(errors_1.ParserDiagnostics.MULTIPLE_ROOTS_FOUND, duplicateRoot);
    }
    const [root] = validRoots;
    if (!root || !parse5Utils.isElementNode(root)) {
        ctx.throwAtLocation(errors_1.ParserDiagnostics.MISSING_ROOT_TEMPLATE_TAG);
    }
    return root;
}
function applyHandlers(ctx, element, parsedAttr) {
    let eventHandlerAttribute;
    while ((eventHandlerAttribute = parsedAttr.pick(constants_1.EVENT_HANDLER_RE))) {
        const { name } = eventHandlerAttribute;
        if (!(0, ir_1.isIRExpressionAttribute)(eventHandlerAttribute)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.EVENT_HANDLER_SHOULD_BE_EXPRESSION, eventHandlerAttribute);
        }
        if (!name.match(constants_1.EVENT_HANDLER_NAME_RE)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.INVALID_EVENT_NAME, eventHandlerAttribute, [name]);
        }
        // Light DOM slots cannot have events because there's no actual `<slot>` element
        if (element.tag === 'slot' && ctx.getRenderMode(element) === types_1.LWCDirectiveRenderMode.light) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.LWC_LIGHT_SLOT_INVALID_EVENT_LISTENER, element, [
                name,
            ]);
        }
        // Strip the `on` prefix from the event handler name
        const eventName = name.slice(2);
        const on = element.on || (element.on = {});
        on[eventName] = eventHandlerAttribute.value;
    }
}
function applyIf(ctx, element, parsedAttr) {
    const ifAttribute = parsedAttr.pick(constants_1.IF_RE);
    if (!ifAttribute) {
        return;
    }
    if (!(0, ir_1.isIRExpressionAttribute)(ifAttribute)) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.IF_DIRECTIVE_SHOULD_BE_EXPRESSION, ifAttribute);
    }
    const [, modifier] = ifAttribute.name.split(':');
    if (!constants_1.VALID_IF_MODIFIER.has(modifier)) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.UNEXPECTED_IF_MODIFIER, ifAttribute, [modifier]);
    }
    element.if = ifAttribute.value;
    element.ifModifier = modifier;
}
function applyLwcDirectives(ctx, element, parsedAttr) {
    const lwcAttribute = parsedAttr.get(constants_1.LWC_RE);
    if (!lwcAttribute) {
        return;
    }
    if (!constants_1.LWC_DIRECTIVE_SET.has(lwcAttribute.name) &&
        !constants_1.ROOT_TEMPLATE_DIRECTIVES_SET.has(lwcAttribute.name)) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.UNKNOWN_LWC_DIRECTIVE, element, [
            lwcAttribute.name,
            `<${element.tag}>`,
        ]);
    }
    const lwcOpts = {};
    applyLwcDynamicDirective(ctx, element, parsedAttr, lwcOpts);
    applyLwcDomDirective(ctx, element, parsedAttr, lwcOpts);
    applyLwcRenderModeDirective(ctx, element, parsedAttr, lwcOpts);
    applyLwcPreserveCommentsDirective(ctx, element, parsedAttr, lwcOpts);
    element.lwc = lwcOpts;
}
function applyLwcRenderModeDirective(ctx, element, parsedAttr, lwcOpts) {
    const lwcRenderModeAttribute = parsedAttr.get(constants_1.ROOT_TEMPLATE_DIRECTIVES.RENDER_MODE);
    if (!lwcRenderModeAttribute) {
        return;
    }
    if (!(0, ir_1.isIRStringAttribute)(lwcRenderModeAttribute) ||
        (lwcRenderModeAttribute.value !== 'shadow' && lwcRenderModeAttribute.value !== 'light')) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.LWC_RENDER_MODE_INVALID_VALUE, element);
    }
    if (ctx.parentStack.length > 0) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.UNKNOWN_LWC_DIRECTIVE, element, [
            constants_1.ROOT_TEMPLATE_DIRECTIVES.RENDER_MODE,
            `<${element.tag}>`,
        ]);
    }
    lwcOpts.renderMode = lwcRenderModeAttribute.value;
}
function applyLwcPreserveCommentsDirective(ctx, element, parsedAttr, lwcOpts) {
    const lwcPreserveCommentAttribute = parsedAttr.get(constants_1.ROOT_TEMPLATE_DIRECTIVES.PRESERVE_COMMENTS);
    if (!lwcPreserveCommentAttribute) {
        return;
    }
    if (ctx.parentStack.length > 0 || !(0, ir_1.isIRBooleanAttribute)(lwcPreserveCommentAttribute)) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.UNKNOWN_LWC_DIRECTIVE, element, [
            constants_1.ROOT_TEMPLATE_DIRECTIVES.RENDER_MODE,
            `<${element.tag}>`,
        ]);
    }
    lwcOpts.preserveComments = lwcPreserveCommentAttribute;
}
function applyLwcDynamicDirective(ctx, element, parsedAttr, lwcOpts) {
    const { tag } = element;
    const lwcDynamicAttribute = parsedAttr.pick(constants_1.LWC_DIRECTIVES.DYNAMIC);
    if (!lwcDynamicAttribute) {
        return;
    }
    if (!ctx.config.experimentalDynamicDirective) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.INVALID_OPTS_LWC_DYNAMIC, element, [`<${tag}>`]);
    }
    if (!(0, ir_1.isCustomElement)(element)) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.INVALID_LWC_DYNAMIC_ON_NATIVE_ELEMENT, element, [
            `<${tag}>`,
        ]);
    }
    if (!(0, ir_1.isIRExpressionAttribute)(lwcDynamicAttribute)) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.INVALID_LWC_DYNAMIC_LITERAL_PROP, element, [
            `<${tag}>`,
        ]);
    }
    lwcOpts.dynamic = lwcDynamicAttribute.value;
}
function applyLwcDomDirective(ctx, element, parsedAttr, lwcOpts) {
    const { tag } = element;
    const lwcDomAttribute = parsedAttr.pick(constants_1.LWC_DIRECTIVES.DOM);
    if (!lwcDomAttribute) {
        return;
    }
    if (ctx.getRenderMode(element) === types_1.LWCDirectiveRenderMode.light) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.LWC_DOM_INVALID_IN_LIGHT_DOM, element, [`<${tag}>`]);
    }
    if ((0, ir_1.isCustomElement)(element)) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.LWC_DOM_INVALID_CUSTOM_ELEMENT, element, [`<${tag}>`]);
    }
    if (tag === 'slot') {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.LWC_DOM_INVALID_SLOT_ELEMENT, element);
    }
    if (!(0, ir_1.isIRStringAttribute)(lwcDomAttribute) ||
        shared_1.hasOwnProperty.call(types_1.LWCDirectiveDomMode, lwcDomAttribute.value) === false) {
        const possibleValues = Object.keys(types_1.LWCDirectiveDomMode)
            .map((value) => `"${value}"`)
            .join(', or ');
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.LWC_DOM_INVALID_VALUE, element, [possibleValues]);
    }
    lwcOpts.dom = lwcDomAttribute.value;
}
function applyForEach(ctx, element, parsedAttr) {
    const forEachAttribute = parsedAttr.pick(constants_1.FOR_DIRECTIVES.FOR_EACH);
    const forItemAttribute = parsedAttr.pick(constants_1.FOR_DIRECTIVES.FOR_ITEM);
    const forIndex = parsedAttr.pick(constants_1.FOR_DIRECTIVES.FOR_INDEX);
    if (forEachAttribute && forItemAttribute) {
        if (!(0, ir_1.isIRExpressionAttribute)(forEachAttribute)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.FOR_EACH_DIRECTIVE_SHOULD_BE_EXPRESSION, forEachAttribute);
        }
        if (!(0, ir_1.isIRStringAttribute)(forItemAttribute)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.FOR_ITEM_DIRECTIVE_SHOULD_BE_STRING, forItemAttribute);
        }
        const item = (0, expression_1.parseIdentifier)(ctx, forItemAttribute.value, forItemAttribute.location);
        let index;
        if (forIndex) {
            if (!(0, ir_1.isIRStringAttribute)(forIndex)) {
                ctx.throwOnIRNode(errors_1.ParserDiagnostics.FOR_INDEX_DIRECTIVE_SHOULD_BE_STRING, forIndex);
            }
            index = (0, expression_1.parseIdentifier)(ctx, forIndex.value, forIndex.location);
        }
        element.forEach = {
            expression: forEachAttribute.value,
            item,
            index,
        };
    }
    else if (forEachAttribute || forItemAttribute) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.FOR_EACH_AND_FOR_ITEM_DIRECTIVES_SHOULD_BE_TOGETHER, element);
    }
}
function applyIterator(ctx, element, parsedAttr) {
    const iteratorExpression = parsedAttr.pick(constants_1.ITERATOR_RE);
    if (!iteratorExpression) {
        return;
    }
    if (element.forEach) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.INVALID_FOR_EACH_WITH_ITERATOR, element, [
            iteratorExpression.name,
        ]);
    }
    const iteratorAttributeName = iteratorExpression.name;
    const [, iteratorName] = iteratorAttributeName.split(':');
    if (!(0, ir_1.isIRExpressionAttribute)(iteratorExpression)) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.DIRECTIVE_SHOULD_BE_EXPRESSION, iteratorExpression, [
            iteratorExpression.name,
        ]);
    }
    const iterator = (0, expression_1.parseIdentifier)(ctx, iteratorName, iteratorExpression.location);
    element.forOf = {
        expression: iteratorExpression.value,
        iterator,
    };
}
function applyKey(ctx, element, parsedAttr) {
    const { tag } = element;
    const keyAttribute = parsedAttr.pick('key');
    if (keyAttribute) {
        if (!(0, ir_1.isIRExpressionAttribute)(keyAttribute)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.KEY_ATTRIBUTE_SHOULD_BE_EXPRESSION, keyAttribute);
        }
        const forOfParent = getForOfParent(ctx);
        const forEachParent = getForEachParent(ctx, element);
        if (forOfParent) {
            if (attributeExpressionReferencesForOfIndex(keyAttribute, forOfParent.forOf)) {
                ctx.throwOnIRNode(errors_1.ParserDiagnostics.KEY_SHOULDNT_REFERENCE_ITERATOR_INDEX, keyAttribute, [tag]);
            }
        }
        else if (forEachParent) {
            if (attributeExpressionReferencesForEachIndex(keyAttribute, forEachParent.forEach)) {
                const name = 'name' in keyAttribute.value && keyAttribute.value.name;
                ctx.throwOnIRNode(errors_1.ParserDiagnostics.KEY_SHOULDNT_REFERENCE_FOR_EACH_INDEX, keyAttribute, [tag, name]);
            }
        }
        element.forKey = keyAttribute.value;
    }
    else if (isInIteratorElement(ctx, element) && !(0, ir_1.isTemplate)(element)) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.MISSING_KEY_IN_ITERATOR, element, [tag]);
    }
}
function applyComponent(element) {
    const { tag } = element;
    // Check if the element tag is a valid custom element name and is not part of known standard
    // element name containing a dash.
    if (!tag.includes('-') || constants_1.DASHED_TAGNAME_ELEMENT_SET.has(tag)) {
        return;
    }
    element.component = tag;
}
function applySlot(ctx, element, parsedAttr) {
    // Early exit if the element is not a slot
    if (element.tag !== 'slot') {
        return;
    }
    if (element.forEach || element.forOf || element.if) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.SLOT_TAG_CANNOT_HAVE_DIRECTIVES, element);
    }
    // Can't handle slots in applySlot because it would be too late for class and style attrs
    if (ctx.getRenderMode(element) === types_1.LWCDirectiveRenderMode.light) {
        const invalidAttrs = parsedAttr
            .getAttributes()
            .filter(({ name }) => name !== 'name')
            .map(({ name }) => name);
        if (invalidAttrs.length > 0) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.LWC_LIGHT_SLOT_INVALID_ATTRIBUTES, element, [
                invalidAttrs.join(','),
            ]);
        }
    }
    // Default slot have empty string name
    let name = '';
    const nameAttribute = parsedAttr.get('name');
    if (nameAttribute) {
        if ((0, ir_1.isIRExpressionAttribute)(nameAttribute)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.NAME_ON_SLOT_CANNOT_BE_EXPRESSION, nameAttribute);
        }
        else if ((0, ir_1.isIRStringAttribute)(nameAttribute)) {
            name = nameAttribute.value;
        }
    }
    element.slotName = name;
    const alreadySeen = ctx.seenSlots.has(name);
    ctx.seenSlots.add(name);
    if (alreadySeen) {
        return ctx.warnOnIRNode(errors_1.ParserDiagnostics.NO_DUPLICATE_SLOTS, element, [
            name === '' ? 'default' : `name="${name}"`,
        ]);
    }
    else if (isInIteration(ctx, element)) {
        return ctx.warnOnIRNode(errors_1.ParserDiagnostics.NO_SLOTS_IN_ITERATOR, element, [
            name === '' ? 'default' : `name="${name}"`,
        ]);
    }
}
function applyAttributes(ctx, element, parsedAttr) {
    const { tag } = element;
    const attributes = parsedAttr.getAttributes();
    for (const attr of attributes) {
        const { name } = attr;
        if (!(0, attribute_1.isValidHTMLAttribute)(tag, name)) {
            ctx.warnOnIRNode(errors_1.ParserDiagnostics.INVALID_HTML_ATTRIBUTE, attr, [name, tag]);
        }
        if (name.match(/[^a-z0-9]$/)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.ATTRIBUTE_NAME_MUST_END_WITH_ALPHA_NUMERIC_CHARACTER, attr, [name, tag]);
        }
        if (!/^-*[a-z]/.test(name)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.ATTRIBUTE_NAME_MUST_START_WITH_ALPHABETIC_OR_HYPHEN_CHARACTER, attr, [name, tag]);
        }
        // disallow attr name which combines underscore character with special character.
        // We normalize camel-cased names with underscores caMel -> ca-mel; thus sanitization.
        if (name.match(/_[^a-z0-9]|[^a-z0-9]_/)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.ATTRIBUTE_NAME_CANNOT_COMBINE_UNDERSCORE_WITH_SPECIAL_CHARS, attr, [name, tag]);
        }
        if ((0, ir_1.isIRStringAttribute)(attr)) {
            if (name === 'id') {
                const { value } = attr;
                if (/\s+/.test(value)) {
                    ctx.throwOnIRNode(errors_1.ParserDiagnostics.INVALID_ID_ATTRIBUTE, attr, [value]);
                }
                if (isInIteration(ctx, element)) {
                    ctx.throwOnIRNode(errors_1.ParserDiagnostics.INVALID_STATIC_ID_IN_ITERATION, attr, [
                        value,
                    ]);
                }
                if (ctx.seenIds.has(value)) {
                    ctx.throwOnIRNode(errors_1.ParserDiagnostics.DUPLICATE_ID_FOUND, attr, [value]);
                }
                else {
                    ctx.seenIds.add(value);
                }
            }
        }
        // Prevent usage of the slot attribute with expression.
        if (name === 'slot' && (0, ir_1.isIRExpressionAttribute)(attr)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.SLOT_ATTRIBUTE_CANNOT_BE_EXPRESSION, attr);
        }
        // the if branch handles
        // 1. All attributes for standard elements except 1 case are handled as attributes
        // 2. For custom elements, only key, slot and data are handled as attributes, rest as properties
        if ((0, attribute_1.isAttribute)(element, name)) {
            const attrs = element.attrs || (element.attrs = {});
            attrs[name] = attr;
        }
        else {
            const props = element.props || (element.props = {});
            props[(0, attribute_1.attributeToPropertyName)(name)] = attr;
            parsedAttr.pick(name);
        }
    }
}
function validateElement(ctx, element, node) {
    const { tag, namespace, location } = element;
    const isRoot = ctx.parentStack.length === 0;
    if (isRoot) {
        if (!(0, ir_1.isTemplate)(element)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.ROOT_TAG_SHOULD_BE_TEMPLATE, element, [tag]);
        }
        const rootHasUnknownAttributes = node.attrs.some(({ name }) => !constants_1.ROOT_TEMPLATE_DIRECTIVES_SET.has(name));
        if (rootHasUnknownAttributes) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.ROOT_TEMPLATE_HAS_UNKNOWN_ATTRIBUTES, element);
        }
    }
    // Check if a non-void element has a matching closing tag.
    //
    // Note: Parse5 currently fails to collect end tag location for element with a tag name
    // containing an upper case character (inikulin/parse5#352).
    const hasClosingTag = Boolean(location.endTag);
    const isVoidElement = constants_1.VOID_ELEMENT_SET.has(tag);
    if (!isVoidElement && !hasClosingTag && tag === tag.toLocaleLowerCase()) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.NO_MATCHING_CLOSING_TAGS, element, [tag]);
    }
    if (tag === 'style' && namespace === constants_1.HTML_NAMESPACE_URI) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.STYLE_TAG_NOT_ALLOWED_IN_TEMPLATE, element);
    }
    else if ((0, ir_1.isTemplate)(element)) {
        // We check if the template element has some modifier applied to it. Directly checking if one of the
        // IRElement property is impossible. For example when an error occurs during the parsing of the if
        // expression, the `element.if` property remains undefined. It would results in 2 warnings instead of 1:
        //      - Invalid if expression
        //      - Unexpected template element
        //
        // Checking if the original HTMLElement has some attributes applied is a good enough for now.
        const hasAttributes = node.attrs.length !== 0;
        if (!isRoot && !hasAttributes) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.NO_DIRECTIVE_FOUND_ON_TEMPLATE, element);
        }
    }
    else {
        const isNotAllowedHtmlTag = constants_1.DISALLOWED_HTML_TAGS.has(tag);
        if (namespace === constants_1.HTML_NAMESPACE_URI && isNotAllowedHtmlTag) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.FORBIDDEN_TAG_ON_TEMPLATE, element, [tag]);
        }
        const isNotAllowedSvgTag = !constants_1.SUPPORTED_SVG_TAGS.has(tag);
        if (namespace === constants_1.SVG_NAMESPACE_URI && isNotAllowedSvgTag) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.FORBIDDEN_SVG_NAMESPACE_IN_TEMPLATE, element, [
                tag,
            ]);
        }
        const isNotAllowedMathMlTag = constants_1.DISALLOWED_MATHML_TAGS.has(tag);
        if (namespace === constants_1.MATHML_NAMESPACE_URI && isNotAllowedMathMlTag) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.FORBIDDEN_MATHML_NAMESPACE_IN_TEMPLATE, element, [
                tag,
            ]);
        }
        const isKnownTag = (0, ir_1.isCustomElement)(element) ||
            constants_1.KNOWN_HTML_ELEMENTS.has(tag) ||
            constants_1.SUPPORTED_SVG_TAGS.has(tag) ||
            constants_1.DASHED_TAGNAME_ELEMENT_SET.has(tag);
        if (!isKnownTag) {
            ctx.warnOnIRNode(errors_1.ParserDiagnostics.UNKNOWN_HTML_TAG_IN_TEMPLATE, element, [tag]);
        }
    }
}
function validateChildren(ctx, element) {
    var _a;
    const effectiveChildren = ctx.getPreserveComments(element)
        ? element.children
        : element.children.filter((child) => child.type !== 'comment');
    if (((_a = element.lwc) === null || _a === void 0 ? void 0 : _a.dom) && effectiveChildren.length > 0) {
        ctx.throwOnIRNode(errors_1.ParserDiagnostics.LWC_DOM_INVALID_CONTENTS, element);
    }
}
function validateAttributes(ctx, element, parsedAttr) {
    const { tag } = element;
    const attributes = parsedAttr.getAttributes();
    for (const attr of attributes) {
        const { name: attrName } = attr;
        if ((0, attribute_1.isProhibitedIsAttribute)(attrName)) {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.IS_ATTRIBUTE_NOT_SUPPORTED, element, [
                attrName,
                tag,
            ]);
        }
        if ((0, attribute_1.isTabIndexAttribute)(attrName)) {
            if (!(0, ir_1.isIRExpressionAttribute)(attr) && !(0, attribute_1.isValidTabIndexAttributeValue)(attr.value)) {
                ctx.throwOnIRNode(errors_1.ParserDiagnostics.INVALID_TABINDEX_ATTRIBUTE, element);
            }
        }
        // TODO [#1136]: once the template compiler emits the element namespace information to the engine we should
        // restrict the validation of the "srcdoc" attribute on the "iframe" element only if this element is
        // part of the HTML namespace.
        if (tag === 'iframe' && attrName === 'srcdoc') {
            ctx.throwOnIRNode(errors_1.ParserDiagnostics.FORBIDDEN_IFRAME_SRCDOC_ATTRIBUTE, element);
        }
    }
}
function validateProperties(ctx, element) {
    const { tag, props } = element;
    if (props !== undefined) {
        for (const propName in props) {
            const propAttr = props[propName];
            const { name: attrName, value } = propAttr;
            if ((0, attribute_1.isProhibitedIsAttribute)(attrName)) {
                ctx.throwOnIRNode(errors_1.ParserDiagnostics.IS_ATTRIBUTE_NOT_SUPPORTED, element, [
                    attrName,
                    tag,
                ]);
            }
            if ((0, attribute_1.isTabIndexAttribute)(attrName) &&
                !(0, ir_1.isIRExpressionAttribute)(propAttr) &&
                !(0, attribute_1.isValidTabIndexAttributeValue)(value)) {
                ctx.throwOnIRNode(errors_1.ParserDiagnostics.INVALID_TABINDEX_ATTRIBUTE, element);
            }
        }
    }
}
function parseAttributes(ctx, element, node) {
    const parsedAttrs = new attribute_1.ParsedAttribute();
    const { attrs: attributes } = node;
    for (const attr of attributes) {
        parsedAttrs.append(getTemplateAttribute(ctx, element, attr));
    }
    return parsedAttrs;
}
function getTemplateAttribute(ctx, element, attribute) {
    const name = (0, attribute_1.attributeName)(attribute);
    // Convert attribute name to lowercase because the location map keys follow the algorithm defined in the spec
    // https://wicg.github.io/controls-list/html-output/multipage/syntax.html#attribute-name-state
    const location = element.location.attrs[name.toLowerCase()];
    const rawAttribute = ctx.getSource(location.startOffset, location.endOffset);
    const { tag } = element;
    // parse5 automatically converts the casing from camelcase to all lowercase. If the attribute name
    // is not the same before and after the parsing, then the attribute name contains capital letters
    if (!rawAttribute.startsWith(name)) {
        ctx.throwAtLocation(errors_1.ParserDiagnostics.INVALID_ATTRIBUTE_CASE, location, [
            rawAttribute,
            tag,
        ]);
    }
    const isBooleanAttribute = !rawAttribute.includes('=');
    const { value, escapedExpression } = (0, attribute_1.normalizeAttributeValue)(ctx, rawAttribute, tag, attribute, location);
    if ((0, expression_1.isExpression)(value) && !escapedExpression) {
        return {
            name,
            location,
            type: types_1.IRAttributeType.Expression,
            value: (0, expression_1.parseExpression)(ctx, value, location),
        };
    }
    else if (isBooleanAttribute) {
        return {
            name,
            location,
            type: types_1.IRAttributeType.Boolean,
            value: true,
        };
    }
    else {
        return {
            name,
            location,
            type: types_1.IRAttributeType.String,
            value,
        };
    }
}
function isInIteration(ctx, element) {
    return ctx.findAncestor({
        predicate: (element) => (0, ir_1.isTemplate)(element) && (element.forOf || element.forEach),
        element,
    });
}
function getForOfParent(ctx) {
    return ctx.findAncestor({
        predicate: (element) => element.forOf,
        traversalCond: ({ current }) => (0, ir_1.isTemplate)(current),
    });
}
function getForEachParent(ctx, element) {
    return ctx.findAncestor({
        element,
        predicate: (element) => element.forEach,
        traversalCond: ({ parent }) => parent && (0, ir_1.isTemplate)(parent),
    });
}
function isInIteratorElement(ctx, element) {
    return !!(getForOfParent(ctx) || getForEachParent(ctx, element));
}
//# sourceMappingURL=index.js.map