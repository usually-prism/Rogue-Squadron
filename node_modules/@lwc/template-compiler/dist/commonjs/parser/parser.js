"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@lwc/errors");
const types_1 = require("../shared/types");
function normalizeLocation(location) {
    let line = 0;
    let column = 0;
    let start = 0;
    let length = 0;
    if (location) {
        const { startOffset, endOffset } = location;
        line = location.startLine;
        column = location.startCol;
        start = startOffset;
        length = endOffset - startOffset;
    }
    return { line, column, start, length };
}
class ParserCtx {
    constructor(source, config) {
        this.warnings = [];
        this.seenIds = new Set();
        this.seenSlots = new Set();
        this.parentStack = [];
        this.source = source;
        this.config = config;
    }
    getSource(start, end) {
        return this.source.slice(start, end);
    }
    *ancestors(element) {
        const ancestors = element ? [...this.parentStack, element] : this.parentStack;
        for (let index = ancestors.length - 1; index > 0; index--) {
            yield { current: ancestors[index], index };
        }
    }
    findAncestor(args) {
        const { element, predicate, traversalCond = () => true } = args;
        for (const { current, index } of this.ancestors(element)) {
            if (predicate(current)) {
                return current;
            }
            if (!traversalCond({ current, parent: this.parentStack[index - 1] })) {
                break;
            }
        }
        return null;
    }
    withErrorRecovery(fn) {
        try {
            return fn();
        }
        catch (error) {
            if (error instanceof errors_1.CompilerError) {
                this.addDiagnostic(error.toDiagnostic());
            }
            else {
                throw error;
            }
        }
    }
    withErrorWrapping(fn, errorInfo, location, msgFormatter) {
        try {
            return fn();
        }
        catch (error) {
            if (msgFormatter) {
                error.message = msgFormatter(error);
            }
            this.throwOnError(errorInfo, error, location);
        }
    }
    throwOnError(errorInfo, error, location) {
        const diagnostic = (0, errors_1.normalizeToDiagnostic)(errorInfo, error, {
            location: normalizeLocation(location),
        });
        throw errors_1.CompilerError.from(diagnostic);
    }
    throwOnIRNode(errorInfo, irNode, messageArgs) {
        this.throwAtLocation(errorInfo, irNode.location, messageArgs);
    }
    throwAtLocation(errorInfo, location, messageArgs) {
        throw (0, errors_1.generateCompilerError)(errorInfo, {
            messageArgs,
            origin: {
                location: normalizeLocation(location),
            },
        });
    }
    warnOnIRNode(errorInfo, irNode, messageArgs) {
        this.warnAtLocation(errorInfo, messageArgs, irNode.location);
    }
    warnAtLocation(errorInfo, messageArgs, location) {
        this.addDiagnostic((0, errors_1.generateCompilerDiagnostic)(errorInfo, {
            messageArgs,
            origin: {
                location: normalizeLocation(location),
            },
        }));
    }
    addDiagnostic(diagnostic) {
        this.warnings.push(diagnostic);
    }
    getRoot(element) {
        return this.parentStack[0] || element;
    }
    getRenderMode(element) {
        var _a, _b;
        return (_b = (_a = this.getRoot(element).lwc) === null || _a === void 0 ? void 0 : _a.renderMode) !== null && _b !== void 0 ? _b : types_1.LWCDirectiveRenderMode.shadow;
    }
    getPreserveComments(element) {
        var _a, _b, _c;
        return ((_c = (_b = (_a = this.getRoot(element).lwc) === null || _a === void 0 ? void 0 : _a.preserveComments) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : this.config.preserveHtmlComments);
    }
}
exports.default = ParserCtx;
//# sourceMappingURL=parser.js.map