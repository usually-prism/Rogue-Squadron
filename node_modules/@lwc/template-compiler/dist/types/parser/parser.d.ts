import * as parse5 from 'parse5';
import { CompilerDiagnostic, LWCErrorInfo } from '@lwc/errors';
import { IRElement, LWCDirectiveRenderMode, IRBaseAttribute, IRNode } from '../shared/types';
import { ResolvedConfig } from '../config';
export default class ParserCtx {
    private readonly source;
    readonly config: ResolvedConfig;
    readonly warnings: CompilerDiagnostic[];
    readonly seenIds: Set<string>;
    readonly seenSlots: Set<string>;
    readonly parentStack: IRElement[];
    constructor(source: String, config: ResolvedConfig);
    getSource(start: number, end: number): string;
    ancestors(element?: IRElement): Generator<{
        current: IRElement;
        index: number;
    }, void, unknown>;
    findAncestor(args: {
        element?: IRElement;
        predicate: (elm: IRElement) => unknown;
        traversalCond?: (nodes: {
            current: IRElement;
            parent: IRElement | null;
        }) => unknown;
    }): IRElement | null;
    withErrorRecovery<T>(fn: () => T): T | undefined;
    withErrorWrapping<T>(fn: () => T, errorInfo: LWCErrorInfo, location: parse5.Location, msgFormatter?: (error: any) => string): T;
    throwOnError(errorInfo: LWCErrorInfo, error: any, location?: parse5.Location): never;
    throwOnIRNode(errorInfo: LWCErrorInfo, irNode: IRNode | IRBaseAttribute, messageArgs?: any[]): never;
    throwAtLocation(errorInfo: LWCErrorInfo, location?: parse5.Location, messageArgs?: any[]): never;
    warnOnIRNode(errorInfo: LWCErrorInfo, irNode: IRNode | IRBaseAttribute, messageArgs?: any[]): void;
    warnAtLocation(errorInfo: LWCErrorInfo, messageArgs?: any[], location?: parse5.Location): void;
    private addDiagnostic;
    getRoot(element: IRElement): IRElement;
    getRenderMode(element: IRElement): LWCDirectiveRenderMode;
    getPreserveComments(element: IRElement): boolean;
}
